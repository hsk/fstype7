# TODOリスト

とりあえず、fsharpで作る事にしてみた。
コンパイラの大部分は作れたので、次の計画を考える。

## OpenGL対応

	○ 複数のファイルに対応
	○ openglに対応

## クラス

バックエンドの設計
フロントエンドの設計


オブジェクト指向の難しさは、項の書き換えと、バックエンドの実装の２つにある。
要するに、


a.add(b,c)で、addがメソッドならば、a.add(a,b,c)に書き換える必要がある。

で、構造ベースの型システムだと、同じ構造だけど、メソッドだけ違うとかがあり得るので困るので、
名前ベースで書くと楽に拡張出来る。

分けて考えたいけど、フロントエンドも必要なので難しい。


- ●とりあえず、structをコピーして入れる。
- ○メソッドが使えるようにする。

	要するに、構造体内にdefがあったら、メソッド扱いにする。
	クラスでも、structでも変わらずに。

入れようと思えば、入れられそう。
で、thisの設定が面倒だったはず。
transduceにある程度処理が入っているので、完成させればいいかもしれない。
継承はない、クラスを作る。

メソッドの難しい所は、this.a()をa(this)に変換する所だ。

this.a(hoge)を一度、型チェックする。すると、型が関数か、メソッドが分かるはず。
この後に、メソッド呼び出しを発見して、A_a(this,hoge)に変換する必要が出てくる。


trait Hoge {

}

class A implements Hoge {
}

構造体は既にあるので、構造体にメソッドを追加する。

構造体ではなくて、クラスを導入する。最初は、構造体のコピーを取るだけでいい。

	typedef A = class {
		var a:int
		def add(b:int):int = a+b
	}

メソッドのコンパイルでは、とにかく、一度動かしたいので、
1. ●クラス_メソッド名でコンパイルする。
2. ○引数にthisを渡す。
3. ○newのときに、メソッドを保存する。

この３つが出来ればよい。

で、１つずつ潰してけば良い。

引数にthisを付け加える必要があるので、どこかで入れよう。
タイプチェックかな。


## 総称関数

generics

## パターンマッチング

### 簡単なパターンマッチング
### Listに対するパターンマッチング
### 複雑なパターンマッチング

## メモリ管理機構

## val

valの書き換え不能のチェックを入れる

## 例外処理

例外を投げて、キャッチする。


## 例外処理巻き戻し機能

例外を関数の終わりに必ずキャッチして、デストラクタ的な処理があれば実行する。

## エラーコードをテストに組み込む

エラーメッセージは変わっても大丈夫なように、エラーコードのみでテスト出来るようにする。

## エラーメッセージテスト

エラーメッセージを纏めて定義する。外部仕様を纏めて奇麗に使いやすくする。

## フォーマッタ

### compact式のフォーマッタ
### lllのフォーマッタ
