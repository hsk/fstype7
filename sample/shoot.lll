import sample.math
import sample.opengl

typedef bool = int

val false:int = 0
val true:int = 1

val GLUT_RGBA:int = 0
val GLUT_NUMBER:int = 2
val GLUT_DEPTH:int = 16
val GLUT_KEY_LEFT:byte = 100
val GLUT_KEY_UP:byte = 101
val GLUT_KEY_RIGHT:byte = 102
val GLUT_KEY_DOWN:byte = 103
val GLUT_KEY_SPACE:byte = 32

val GL_COLOR_BUFFER_BIT:int = 16384
val GL_QUADS:int = 7
val GL_LINE_LOOP:int = 2
val GL_POLYGON:int = 9

val GL_PROJECTION:int = 0x1701
val GL_DEPTH_BUFFER_BIT:int = 0x00000100
val GL_MODELVIEW:int = 0x1700
val GL_DEPTH_TEST:int = 0x0B71
val GL_BLEND:int = 0x0BE2
val GL_SRC_ALPHA:int = 0x0302
val GL_ONE_MINUS_SRC_ALPHA:int = 0x0303
val GL_ONE:int = 1
val GL_LIGHT0:int = 0x4000
val GL_LIGHTING:int = 0x0B50
val GL_POSITION:int = 0x1203
val GL_DIFFUSE:int = 0x1201
val GL_FRONT_AND_BACK:int = 0x0408

def exit(a:int):void

var fullscreen:int = 0

var gameover:Ptr[GameOver]
var ship:Ptr[Ship]

var enemies:Array[Ptr[Enemy],10]
var enemiesCnt:int = 10
var bullets:Array[Ptr[Bullet],50]
var bulletsCnt:int = 50
var particles:Array[Ptr[Particle], 50]
var particlesCnt:int = 50
var shots:Array[Ptr[Shot],10]
var shotsCnt:int = 10
var score:int = 0
var rank:int = 0
var randomValue:int = 1143241
var key:Ptr[Key]



def main(argc:int, argv:Ptr[Ptr[char]]) {
	key = newKey()
	ship = newShip(0.0, 0.0)
	ship.init()
	
	gameover = new GameOver
	
/*
	gameover.text = "GAME OVER";
	gameover.y = 200;
	gameover.x = 200;
*/
	var i:int
	for(i = 0; i < bulletsCnt;i++) {
		bullets[i] = newBullet()
	}

	for(i = 0; i < particlesCnt;i++) {
		particles[i] = newParticle()
	}
	for(i = 0; i < shotsCnt;i++) {
		shots[i] = newShot()
	}
	for(i = 0; i < enemiesCnt;i++) {
		enemies[i] = newEnemy()
	}

  	glutInit(&argc, argv)
  	glutInitWindowSize(640, 480)
  	if (0) {
		glutGameModeString("640x480:32@60")
		glutEnterGameMode()
  	} else {
		glutCreateWindow(argv[0])
  	}
  	//  glutFullScreen()
  	glutInitDisplayMode(GLUT_RGBA)
  	//glEnable(GL_DEPTH_TEST)
  	glEnable(GL_BLEND)
  	glEnable(GL_LIGHTING)
  	glEnable(GL_LIGHT0)
  
  	glutDisplayFunc(main_display)
  	glutTimerFunc(20, main_loop, 0)

  	glutSpecialFunc(downKey)
  	glutSpecialUpFunc(upKey)
  	glutMainLoop()
}

def main_loop(a:int) {
	onEnter()
	glutPostRedisplay()
	glutTimerFunc(20 , main_loop , 0)
}

def random():double = {
	randomValue = randomValue * 143242143 + 432414321
	var a:double = 0x7ffffffff
	randomValue = randomValue & 0x7fffffff
	var b:double = cast(double)randomValue
	(b / a)
}

def onEnter() {
	var cnt = 0
	for (var i = 0; i < enemiesCnt; i++) {
		var enemy = enemies[i]
		if (enemy.visible) {
			cnt++
			enemy.move(enemy)
		}
	}
	if(cnt == 0 || random()*100 < rank) {
		var rn1 = random()*3
		var rnd = cast(int)(rn1)
		switch(rnd) {
		case 0: addEnemy(0.0, random() * 200.0, 0.0); break
		case 1: addEnemy(random() * 465.0, 0.0, PI / 2.0); break
		case 2: addEnemy(465.0, random() * 200.0, PI); break
		}
	}
	if (gameover.visible && key.start) {
		score = 0
		rank = 1
		gameover.visible = false
		ship.init()
	}

	if(ship.visible)ship.move()

	for (i = 0; i < bulletsCnt; i++) {
		var b = bullets[i]
		if(b.visible) {
			b.move()
			if(ship.exists && abs(ship.x - b.x) < 3 && abs(ship.y - b.y) < 3) {
				addParticles(ship.x, ship.y, 100)
				ship.exists = false
				ship.visible = false
				gameover.visible = true
			}
		}
	}

	for (i = 0; i < shotsCnt; i++) {
		var s = shots[i]
		if (s.visible) {
			/*
			for (var j = 0; j < enemiesCnt; j++) {
				var enemy = enemies[j]
				if(enemy.visible && abs(enemy.x - s.x) < 30 && abs(enemy.y - s.y) < 30) {
					score += 100
					rank = score / 1000
					addParticles(enemy.x, enemy.y, 30)
					enemy.visible = false
				}
			}*/
			s.move()
		}
	}
	for (i = 0; i < particlesCnt; i++) {
		var p = particles[i]
		if(p.visible) p.move()
	}
//	txt.text = "SCORE "+score;
}

def glFrustum(a:double,b:double,c:double,d:double,e:double,f:double):void

def color(r:float,g:float,b:float,a:float) {
	var col = Array(r,g,b,a)
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, col)
}

def main_display() {
  	var WIDTH:int = 640
  	var HEIGHT:int = 480
  
  	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  	glViewport(0, 0, 640, 480)

  	glMatrixMode(GL_PROJECTION)
  	glLoadIdentity()

  	//視野角,アスペクト比(ウィンドウの幅/高さ),描画する範囲(最も近い距離,最も遠い距離)
  	gluPerspective(90.0, cast(double)WIDTH / cast(double)HEIGHT, 1.0, 10000.0)
// 	glFrustum(-1*cast(double)WIDTH, cast(double)WIDTH * 1.0, cast(double)HEIGHT * 1.0, cast(double)HEIGHT * -0.5, cast(double)HEIGHT, 100000.0);
 	// ライトの設定
 	var n:float = 10.0
 	var lightpos:Array[float,4]

 	lightpos[0] = 500.0 * n
 	lightpos[1] = 802.0 * n
 	lightpos[2] = 505.0 * n
 	lightpos[3] = 1.0
  	glLightfv(GL_LIGHT0, GL_POSITION, cast(Ptr[float])lightpos)

  	glMatrixMode(GL_MODELVIEW)
  	glLoadIdentity()
  	glBlendFunc(GL_SRC_ALPHA, GL_ONE)
  	gluLookAt(0.0,0.0,320.0, //カメラの座標
		0.0,0.0,0.0, // 注視点の座標
		0.0,1.0,0.0) // 画面の上方向を指すベクトル 
		
 
	for (var i = 0; i < enemiesCnt; i++) {
		var enemy = enemies[i]
		if (enemy.visible) {
			enemy.draw()
		}
	}

	if(gameover.visible) {
	}

	if(ship.visible)ship.draw()

	for (i = 0; i < bulletsCnt; i++) {
		var b = bullets[i]
		if(b.visible) {
			b.draw()
		}
	}

	for (i = 0; i < shotsCnt; i++) {
		var s = shots[i]
		if (s.visible) {
			s.draw()
		}
	}

	for (i = 0; i < particlesCnt; i++) {
		var p = particles[i]
		if(p.visible) p.draw()
	}
   
  	glFlush()
}

def addParticles(x:double, y:double, n:int) {
	for (var i:int = 0; i < n; i++) {
		addParticle(x, y, random() * 100)
	}
}

def addBulletN(x:double, y:double, rad:double, n:int, r:double) {
	for (var i:int = 0; i < n; i++) {
		addBullet(x, y, rad +(cast(double)i - cast(double)n / 2.0) * r)
	}
}

def addBullet(x:double, y:double, rad:double) {
	for (var i:int = 0; i < bulletsCnt; i++) {
		var b = bullets[i]
		if(b.visible) continue
		b.init(x, y, rad)
		return
	}
}

def addShot(x:double, y:double, rad:double) {
	for (var i:int = 0; i < shotsCnt; i++) {
		var b = shots[i]
		if(!b.visible) {
			b.init(x, y, rad)
			return
		}
	}
}

def addParticle(x:double, y:double, rad:double) {
	for (var i:int = 0; i < particlesCnt; i++) {
		var b = particles[i]
		if(!b.visible) {
		  b.init(x, y, rad)
		  return
		}
	}
}

def addEnemy(x:double, y:double, rad:double) {
	for (var i:int = 0; i < enemiesCnt; i++) {
		var b = enemies[i]
		if(b.visible) continue
		println("enemy_init")
		print_i(i)
		b.init(x, y, rad)
		return
	}
}

val PI = 3.141592

def normalRad(v:double):double = {
	v + 2 * PI * (
		if (v >  PI) -1 else
		if (v < -PI) 1 else 0
	)
}

typedef Key = class {
	up:int
	down:int
	left:int
	right:int
	space:int
	shot:int
	start:int

	def init() {
		this.up = this.down = this.left = this.right = this.space = this.shot = this.start = 0
	}

	def downKey(k:byte) {
		k is {
		GLUT_KEY_UP? this.up = 1 break
		GLUT_KEY_DOWN? this.down = 1 break
		GLUT_KEY_LEFT? this.left = 1 break
		GLUT_KEY_RIGHT? this.right = 1 break
		GLUT_KEY_SPACE? this.start = this.shot = this.space = 1 break
		}
	}
	
	def upKey(k:byte) {
		k is {
		GLUT_KEY_UP? this.up = 0 break
		GLUT_KEY_DOWN? this.down = 0 break
		GLUT_KEY_LEFT? this.left = 0 break
		GLUT_KEY_RIGHT? this.right = 0 break
		GLUT_KEY_SPACE? this.start = this.shot = this.space = 0 break
		27? glutLeaveGameMode() exit(0) break
		}
	}
}

def newKey():Ptr[Key] = {
	var key = new Key
	key.init()
	key
}

def downKey(k:byte, x:int, y:int) {
	key.downKey(k)
}

def upKey(k:byte, x:int, y:int) {
	key.upKey(k)
}

typedef GameOver = class {
	visible:bool
}

typedef Ship = class {

	x:double
	y:double
	visible:bool
	speed:double
	exists:bool
	timer:int

	def this(x:double, y:double) {
		this.speed = 5.0
		this.x = x
		this.y = y
	}

	def init() {
		this.exists = false
		this.timer = 0
		this.visible = true
	}

	def move() {
	  	this.timer++
	  	var x = this.x
	  
		if(this.timer > 300) this.exists = true
		
		if(key.shot)addShot(this.x, this.y, -PI / 2)
		if(key.left)this.x -= this.speed
		if(key.right)this.x += this.speed
		if(key.up)this.y -= this.speed
		if(key.down)this.y += this.speed
		
		if(this.x < 0) this.x = 5 else if(this.x > 465) this.x = 465 - 5
		if(this.y < 0) this.y = 5 else if(this.y > 465) this.y = 465 - 5
		
		if(x != this.x) print_d(this.x)
	}

	def draw() {
		
		glPushMatrix() 
		glTranslated(this.x, this.y, 0.0)

		var x = 15.0
		var y = 30.0
		glBegin(GL_POLYGON)
			color(1.0,0.275,0.275,1.0)
			glNormal3d(0.0,0.0,1.0)
			glVertex3d(-x,y,0.0)
			glVertex3d(x,y,0.0)
			glVertex3d(x,-y,0.0)
			glVertex3d(-x,-y,0.0)
		glEnd()
		glPopMatrix() 
	}

}

def newShip(x:double, y:double):Ptr[Ship] = {
	var this = new Ship
	this.speed = 5.0
	this.x = x
	this.y = y
	this
}

typedef Enemy = class {
	x:double
	y:double
	visible:bool
	speed:double
	rad:double
	r:double
	move:(Ptr[Enemy])=>void
	nextMove:(Ptr[Enemy])=>void
	time:int
	r2:double

	def init(x:double, y:double, rad:double) {
		this.x = x
		this.y = y
		this.rad = atan((y - ship.y) / (x - ship.x))
		this.visible = true
		this.move = Enemy_move1
	}

	def draw() {
		glPushMatrix()
		glTranslated(this.x, this.y, 0.0)

		var x = 15.0
		var y = 15.0
		glBegin(GL_POLYGON)
			color(1.0,0.5,1.0,0.0)
			glNormal3d(0.0,0.0,1.0)
			glVertex3d(-x,y,0.0)
			glVertex3d(x,y,0.0)
			glVertex3d(x,-y,0.0)
			glVertex3d(-x,-y,0.0)
		glEnd()
		glPopMatrix() 
	}


	def moveBody():double = {
		var rad2:double = atan2(ship.y - this.y, ship.x - this.x)
		if (normalRad(this.rad - rad2) < 0) this.rad += this.r
		else this.rad -= this.r
		this.rad = normalRad(this.rad)
		this.x += cos(this.rad) * this.speed
		this.y += sin(this.rad) * this.speed
		if(this.x < 0) this.x = 5 else if(this.x > 465) this.x = 465 - 5
		if(this.y < 0) this.y = 5 else if(this.y > 465) this.y = 465 - 5
		return rad2
	}

	def wait(w:int,next:(Ptr[Enemy])=>void) {
		this.time = w
		this.move = Enemy_moveWait
		this.nextMove = next
	}
	
}

def newEnemy():Ptr[Enemy] = {
	var this = new Enemy
	this.speed = 5
	this.rad = 0
	this.r = 0.05
	this.r2 = 0
	this.visible = false
	this
}


def Enemy_moveWait(this:Ptr[Enemy]) {
	this.moveBody()
	this.time -= 1
	if(this.time <= 0) {
		this.move = this.nextMove
	}
}

def Enemy_move1(this:Ptr[Enemy]) {
	println("enemy_move1")
	print_d(this.x)
	print_d(this.y)
	var r:double = this.moveBody()
	if(random() > 0.8) {
		addBullet(this.x, this.y, this.r)
		if(random() > 0.8) {
			this.r2 = 0
			this.wait(30, Enemy_move2);
		}
	}
}

def Enemy_move2(this:Ptr[Enemy]) {
	var r:double = this.moveBody()
	var rr:int = cast(int)(random() * 5.0 + 1.0)
	addBulletN(this.x, this.y, r + this.r2, rr, 0.1)
	this.r2 = this.r2 + cast(double)rr * 0.1
	if(random() < 0.03)this.wait(60, Enemy_move1)
}

typedef Particle = class {
	x:double
	y:double
	visible:bool
	speed:double
	rad:double

	def init(x:double, y:double, rad:double) {
		this.x = x
		this.y = y
		this.rad = rad
		this.visible = true
		this.speed = random() * 50 + 10
	}

	def draw() {
		glPushMatrix()
		glTranslated(this.x, this.y, 0.0)

		var x = 5.0
		var y = 5.0
		glBegin(GL_POLYGON)
			color(1.0,0.5,1.0,0.0)
			glNormal3d(0.0,0.0,1.0)
			glVertex3d(-x,y,0.0)
			glVertex3d(x,y,0.0)
			glVertex3d(x,-y,0.0)
			glVertex3d(-x,-y,0.0)
		glEnd()
		glPopMatrix() 
	}


	def move():bool = {
		this.x += cos(this.rad)*this.speed
		this.y += sin(this.rad)*this.speed
		if(this.x < 0 || 465 < this.x || this.y < 0 || 465 < this.y)
			this.visible = false
		this.visible
	}

}

def newParticle():Ptr[Particle] = {
	var this = new Particle
	this.speed = 5
	this.visible = false
	this
}

typedef Bullet = class {
	x:double
	y:double
	visible:bool
	speed:double
	rad:double

	def init(x:double, y:double, rad:double) {
		this.x = x
		this.y = y
		this.rad = rad
		this.visible = true
	}

	def draw() {
		glPushMatrix()
		glTranslated(this.x, this.y, 0.0)

		var x = 5.0
		var y = 5.0
		glBegin(GL_POLYGON)
			color(1.0,0.5,1.0,0.0)
			glNormal3d(0.0,0.0,1.0)
			glVertex3d(-x,y,0.0)
			glVertex3d(x,y,0.0)
			glVertex3d(x,-y,0.0)
			glVertex3d(-x,-y,0.0)
		glEnd()
		glPopMatrix() 
	}

	def move():bool = {
		this.x += cos(this.rad)*this.speed
		this.y += sin(this.rad)*this.speed
		if(this.x < 0 || 465 < this.x || this.y < 0 || 465 < this.y)
		this.visible = false
		this.visible
	}


}

def newBullet():Ptr[Bullet] = {
	var this = new Bullet
	this.visible = false
	this.speed = 10
	this
}

typedef Shot = class {
	x:double
	y:double
	visible:bool
	angle:double
	speed:double
	rad:double

	def init(x:double, y:double, rad:double) {
		this.x = x
		this.y = y
		this.rad = rad
		this.visible = true
	}

	def draw() {
		glPushMatrix() 
		glTranslated(this.x, this.y, 0.0)

		var x = 5.0
		var y = 5.0
		glBegin(GL_POLYGON)
			color(1.0,0.5,1.0,0.5)
			glNormal3d(0.0,0.0,1.0)
			glVertex3d(-x,y,0.0)
			glVertex3d(x,y,0.0)
			glVertex3d(x,-y,0.0)
			glVertex3d(-x,-y,0.0)
		glEnd()
		glPopMatrix() 
	}

	def move():bool = {
		this.x += cos(this.rad) * this.speed
		this.y += sin(this.rad) * this.speed
		if (this.x < 0 || 465 < this.x || this.y < 0 || 465 < this.y)
			this.visible = false
		this.visible
	}

}

def newShot():Ptr[Shot] = {
	var this = new Shot
	this.speed = 25
	this.visible = false
	this
}
